node.js进程模型
---

Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 
Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。

---

### 准备工作

参考资料
> 1. [从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872)


#### 概念先行

- 进程
> 进程是cpu资源分配的最小单位（系统会给它分配内存）

- 线程
> 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

- ps
> 1. 不同进程之间也可以通信，不过代价较大
> 1. 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）

#### 浏览器是多进程的

- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）
- 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。
- 浏览器包含哪些进程？
> 1. browser进程:浏览器主进程(负责协调、主控)【界面展示、用户交互、管理页面、网络资源管理、下载】
> 1. 第三方插件
> 1. gpu（最多一个）
> 1. **浏览器渲染进程（浏览器内核）** 【页面渲染、脚本执行、事件处理】
- 浏览器渲染是多线程的
 1. GUI渲染线程

    > 1. 负责渲染浏览器界面，解析html、css、构建dom和renderObject树，布局和绘制
    > 1. 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
    > 1. 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
    
 2. **JS引擎线程**

    >1. js内核，负责处理Javascript脚本程序。（例如V8引擎）
    >2. JS引擎线程负责解析Javascript脚本，运行代码。
    >3. JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
    >4. 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
   
 3. 事件触发线程
   
    >1. 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
    >2. 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
    >3. 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
    >4. 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
    
 4. 定时器线程

    >1. 传说中的setInterval与setTimeout所在线程
    >2. 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
    >3. 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
    >4. 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

 5. 异步http线程

    >1. 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
    >2. 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

#### others

- 加载顺序
 > DOMContentLoaded -> load

- css与dom
> css加载不会阻塞dom树解析
> css加载会阻塞render树渲染

- 浏览器渲染图层：普通图层 vs 复合图层

 1. 最原始有默认复合层
 1. absolute、fixed 虽然脱离普通文档流，也属于默认复合层
 1. 可以通过**硬件加速**声明一个新的复合图层
 1. 硬件加速方法
 > 1. translate3d translateZ
 > 2. opacity(动画执行时可以)
 > 3. will-change
    
---
---
---

### 正餐开始

Node中的Event Loop是基于libuv实现的

- node的event loop有6个阶段
> 1. timers:执行settimeout和setinterval中到期的cb
> 1. pending callback:上一轮循环中少数的callback会放在这一阶段执行
> 1. idle, prepare: 仅在内部使用
> 1. poll: 最重要的阶段，执行pending callback，在适当的情况下会阻塞在这个阶段
> 1. check: 执行setImmediate(setImmediate()是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行setImmediate指定的回调函数)的callback
> 1. close callbacks: 执行close事件的callback，例如socket.on('close'[,fn])或者http.server.on('close, fn)。

- ps
> 1. 当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行
> 1. setImmediate()设计用于在当前poll阶段完成后check阶段执行脚本 。
> 1. setTimeout() 安排在经过最小（ms）后运行的脚本，在timers阶段执行。


- 进程的九个问题

1. 什么是同步/异步
1. 什么是异步io
1. 什么是阻塞/非阻塞
1. 什么是事件循环与事件驱动
1. 什么是单线程
1. 什么是进程
1. 什么是子进程
1. 怎么启动子进程
1. 进程间如何通信
